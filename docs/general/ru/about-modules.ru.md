# Модули в Startupjs

Мы уже знаем, что startupjs дает возможность кастомизировать приложение с помощью плагинов. И в большинстве случаев этого будет достаточно. Но что делать, если наш плагин содержит в себе такой функционал, который тоже хотелось бы кастомизировать? Например, мы написали плагин для пакета Auth. При этом сам Auth дает возможность подключать разные стратегии авторизации (например, google, linkedIn и другие). В такой ситуации, мы можем создать модуль auth, в котором уже будут подключаться свои плагины, каждый из которых будет реализовывать свою стратегию. Для каждого модуля мы можем создать несколько плагинов. Пользователю достаточно будет установить пакет из startupjs, например, startupjs/auth-google (название дано для примера), и этот пакет будет автоматически подключен. Не надо будет ничего дополнительно настраивать.

Вся концепция модулей (как и плагинов) - это по сути концепция event-эмиттеров, где модуль - это наш eventEmitter, который имитит события, где вместо привычного нам emit выступает hook, а плагины - это функция on для подписки на события.
Единственное отличие от обычного eventEmitter это то, что наш eventEmitter возвращает данные.

## Давайте разберемся, как написать свой модуль на примере модуля admin

Cтруктура нашего модуля выглядит так:

Админка состоит из сайдбара и контентной части. Это общая структура для проектов. А вот страницы, которые будут доступны в админке, индивидуальны для каждого проекта и их добавление и кастомизация в нашем примере будут реализованы через отдельный плагин 'schema', который добавит в наш модуль admin несколько страниц и плагин 'admin-api', который расширит API главного модуля startupjs, добавлением новых эндпоинтов, которые используют новые страницы.

```
    admin/
    │
    ├── client/
    │ ├── _layout.js
    │ ├── index.js
    │ └── routes.js
    │
    ├── index.js
    ├── module.js
    └── package.json
```

Изначально мы должны создать модуль. Для этого в файле `module.js`, который лежит в корне проекта, напишем такой код:

```js
  import { createModule } from 'startupjs/registry'

  export default createModule({
    // name - уникальное название модуля
    name: 'admin'
  })
```

Добавим информацию об этом файле в раздел `exports` файла `package.json` под именем `module.js`, чтобы он автоматически загружался в ваше приложение. Если модуль лежит в отдельной папке, то необходимо учесть путь:

```json
  "exports": {
    "./module": "./module.js"
  }
```

Модули и плагины тесно взаимодействуют друг с другом. Модули предоставляют возможности для адаптации и расширения функционала с помощью плагинов, модули включают в себя хуки для взаимодействия с плагинами. Эти хуки позволяют пользовательским плагинам реализовывать дополнительные функции, реагируя на определенные события или действия внутри модуля.

Рассмотрим один из таких "крючков" на примере файла `routes.js`

```js
    import { createElement as el } from 'react'
    import MODULE from '../module'
    import _layout from './_layout'
    import index from './index'

    export default [{
    path: '',
    element: el(_layout),
    children: [
        { path: '', element: el(index) },
        ...MODULE.hook('routes').flat()
    ]
    }]
```
Для взаимодействия с плагинами мы импортируем MODULE из файла, где мы его создали, и у нас появляется доступ к использованию метода hook у MODULE.

`import MODULE from '../module'`,

Для простоты понимания воспринимаем MODULE.hook('routes') как emit('routes').
Как говорилось ранее, с помощью MODULE.hook('routes') получим массив роутов, который описан в плагине. Если мы не создадим плагин, то события routes у нас не будет и MODULE.hook('routes') нам ничего не вернет.

Создадим плагин 'schema':

```js
  export default createPlugin({
    name: 'schema',
    for: 'admin',
    enabled: true,
    client: () => ({
      routes: () => [
        { path: 'schema', element: <Page /> },
        { path: 'test-page', element: <TestPage /> }
      ],
      menuItems: () => [
        { to: 'schema', name: 'Schema', icon: faTable },
        { to: 'test-page', name: 'TestPage', icon: faTable }
      ]
    })
  })
```

В данном примере мы определяем хук routes, который предназначен для интеграции дополнительных страниц в админ-панель. Когда мы подключаем плагин, модуль сможет эмитить события описанные в плагине. В нашем примере, когда мы эмитим событие routes, плагин предоставляет массив новых страниц, которые будут встроены в административный интерфейс. Логика и содержание этих страниц разрабатываются и описываются непосредственно внутри плагина, обеспечивая модульность и гибкость в расширении админ-панели.

Для того, чтоб "привязать" плагин к нужному модулю, используется свойство for у плагина. Об этом подробнее рассказано в документации о плагинах. Но если в двух словах, то вы просто указываете для for название модуля. Если for не указан, то модулем будет выступать сам startupjs, как корневой модуль.

После того, как мы определили роуты для необходимых страниц, следующий шаг — их отображение в боковой панели административного интерфейса. Для этой цели мы используем событие menuItems. В момент, когда модуль admin запрашивает элементы меню, плагины могут отреагировать на это событие и предоставить данные для меню, включая ссылки на новые страницы, которые были добавлены через роуты. Это обеспечивает динамическую интеграцию страниц в пользовательский интерфейс админ-панели.

В файле `_layout.js`, там где мы выводим menuItems добавим такой код:

```js
  const menuItems = useMemo(() => [
    { name: 'Home', to: adminPath, icon: faTachometerAlt },
    ...MODULE.hook('menuItems').flat().map(item => ({
      ...item,
      to: item.to ? (adminPath + '/' + item.to) : undefined
    }))
  ], [adminPath])
```

Из этого примера видно, что у нас всегда будет страница Home, но если мы подключим плагин schema, когда мы эмитим событие menuItems, MODULE.hook('menuItems') вернет нам массив страниц с путями, описанными в плагине.

Если нам необходимо добавить новые API роуты, которые не были изначально зарегистрированы в startupjs, мы можем сделать это, создав ещё один плагин. Этот плагин будет предназначен непосредственно для расширения функциональности базового модуля startupjs, и в его описании не нужно указывать поле for, поскольку он должен быть обработан самим startupjs.

Таким образом, плагин без поля for будет восприниматься как расширение базового модуля startupjs. Внутри этого плагина мы можем использовать серверный хук api, чтобы добавить новые API роуты, которые будут интегрированы с основным приложением. Это позволит нам обеспечить необходимую связь между новыми страницами админ-панели и соответствующими API вызовами.

```js
    export const startupjsPlugin = createPlugin({
    name: 'admin-api',
    enabled: true,
    server: () => ({
        api: expressApp => {
          expressApp.get(`${BASE_URL}/files`, files)
          expressApp.get(`${BASE_URL}/file/:filename`, getFile)
        }
      })
    })
```

Так же мы можем написать плагин, который выводит какой-либо jsx:

```js
  export default createPlugin({
    name: 'schema',
    for: 'admin',
    enabled: true,
    client: () => ({
      renderTopbarRight: () => (
        <Avatar size='s'>Admin User</Avatar>
        )
    })
  })
```

В случае, когда модуль admin предоставляет возможность расширения через клиентские хуки, мы можем создать плагин, который реализует определенные хуки с предопределенными именами, объявленными в модуле admin. Это позволит интегрировать пользовательский JSX код в определенные части административного интерфейса.

Например, если модуль admin декларирует клиентский хук renderTopbarRight, плагин может реализовать этот хук, чтобы добавить пользовательский компонент в правую часть топбара. Внутри JSX модуля admin, этот хук может быть активирован следующим образом:

При этом плагин должен содержать реализацию для хука с именем renderTopbarRight, чтобы его содержимое могло быть корректно отображено в админ-панели. Это позволяет разработчикам гибко расширять функционал административной панели, добавляя новые элементы интерфейса или функциональность, не меняя исходный код модуля admin.

```js
return pug`
    SmartSidebar.sidebar($open=$sidebarOpened defaultOpen renderContent=renderSidebar)
    Div.topbar(row vAlign='center')
        Div.left(row gap vAlign='center')
        Button(
            variant='text'
            color='text-description'
            icon=faBars
            onPress=() => $sidebarOpened.set(!$sidebarOpened.get())
        )
        H1.title Admin
        Div.right(row gap vAlign='center')
        MODULE.RenderHook(name='renderTopbarRight')
    Slot
    `
```

## Итог
    - Создание модуля происходит с помощь функции createModule.
    - Модуль пишется с учетом будущих модификаций с помощью плагинов.
    - Взаимодействие с плагинами происходит через MODULE.hook(<event_name>)
    - Готовый jsx выводится с помощью клиентского хука `MODULE.RenderHook(name=<event_name>)
    - Самое главное, что нужно знать разработчку, это то, что плагины не существуют отдельно от модулей, они всегда пишутся либо для базового модуля startupjs без явного указания for, либо для новых модулей, как в нашем примере.

Исходя из этого руководства вы научились создавать свои модули и плагины для них.
