import { useRef } from 'react'
import { useValue } from 'startupjs'
import Modal from '../Modal'
import Button from '../Button'
import Br from '../Br'
import { Sandbox } from '@startupjs/docs'

# Modal (модалка)

Наследует [React Native Modal](https://reactnative.dev/docs/modal).

Модалка может быть использована, когда пользователю необходимо сообщить о критической информации, требовать принятия решений или взаимодействовать со сложным подприложением без перехода на новую страницу или прерывания рабочего процесса.

```jsx
import { Modal } from '@startupjs/ui'
```

## Пример

- `showCross` булевое значение, устанавливает отображение крестика в заголовке (по умолчанию `true`)
- `onCrossPress` колбек, который выполняется при нажатии на крестик в заголовке (он имеет более высокий приоритет чем `onCancel`)
- `onCancel` отображает кнопку отмены, которая использует этот обработчик
- `onConfirm` отображает кнопку подтверждения которая использует этот обработчик
- `enableBackdropPress` булевое значение, устанавливает будет ли область вокруг модалки кликабельной (по умолчанию `true`)
- `onBackdropPress` колбек, который выполняется при нажатии на область вокруг модалки
- `onRequestClose` колбек, который выполняется при нажатии физической клавиши `Домой` на Android, клавиши `Esc` в браузере (по умолчанию закрывает модалку)
- `onDismiss` колбек, который выполняется после закрытия модалки любым способом
- `onOrientationChange` колбек, который выполняется при смене ориентации мобильного устройства.

### Для управления состоянием модалки есть два варианта:
  1. `useValue` - вы создаете `useValue` и передаете его сеттер в параметр `$visible` и тогда для закрытия модалки необходимо изменять scope-модель в колбеках, которые передаются в модалку на различные действия (`$visible.set(false)`).
  2. `useRef` - вы создаете `useRef()` и передаете его модалке в параметр `ref` и тогда для управления состоянием модалки сможете вызывать `modalRef.current.open()` и `modalRef.current.close()`. В этом случае необязательно в колбеках `onConfirm` и `onCancel` самим вызывать закрытие модалки, закрытие будет срабатывать автоматически.

```jsx example
const [visible, $visible] = useValue(false)
const modalRef = useRef()

return (
  <React.Fragment>
    <Button onPress={() => $visible.set(true)}>
      Открыть модалку через useValue
    </Button>
    <Br/>
    <Button onPress={() => modalRef.current.open()}>
      Открыть модалку чере useRef
    </Button>
    <Modal
      title='Пример'
      ref={modalRef}
      $visible={$visible}
      dismissLabel='Закрыть'
      confirmLabel='Принять'
      onCrossPress={() => $visible.set(false)}
      onCancel={() => $visible.set(false)}
      onConfirm={() => $visible.set(false)}
      onShow={() => console.log('Modal shown!')}
      onBackdropPress={() => $visible.set(false)}
      onDismiss={() => console.log('onDismiss')}
      onRequestClose={() => $visible.set(false)}
    >
      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit.
    </Modal>
  </React.Fragment>
)
```

## Полноэкранная модалка

По умолчанию модалка отображается как окно в центре страницы. Чтобы сделать её полноэкранной, нужно передать строку `fullscreen` в свойство `variant`.

```jsx example
const [visible, $visible] = useValue(false)

return (
  <React.Fragment>
    <Button onPress={() => $visible.set(true)}>
      Открыть полноэкранную модалку
    </Button>
    <Modal
      variant='fullscreen'
      title='Полноэкранный пример'
      $visible={$visible}
      onCancel={() => $visible.set(false)}
      onConfirm={() => $visible.set(false)}
    >
      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit.
    </Modal>
  </React.Fragment>
)
```

## Продвинутое использование

Модалка состоит из трех частей - `Header`, `Content` и `Actions`. Эти части можно использовать для добавления пользовательской разметки, `Header` используется вместо `title`, `Content` используется вместо `children` и `Actions` используется вместо обработчиков `onCancel`, `onConfirm`. Их можно использовать по отдельности.

```jsx example
const [visible, $visible] = useValue(false)

return (
  <React.Fragment>
    <Button onPress={() => $visible.set(true)}>
      Open advanced modal
    </Button>
    <Modal $visible={$visible}>
      <Modal.Header>Advanced modal</Modal.Header>
      <Modal.Content>
        Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit.
      </Modal.Content>
      <Modal.Actions>
        <Button
          shape='circle'
          onPress={() => $visible.set(false)}
        >
          Custom close
        </Button>
        <Button
          pushed
          shape='circle'
          onPress={() => $visible.set(false)}
        >
          Custom confirm
        </Button>
      </Modal.Actions>
    </Modal>
  </React.Fragment>
)
```

## Sandbox

### Modal

<Sandbox Component={Modal} />

### Modal.Header

<Sandbox Component={Modal.Header} />

### Modal.Content

<Sandbox Component={Modal.Content} />

### Modal.Actions

<Sandbox Component={Modal.Actions} />
