# Startupjs руководство по стилю кода
Чистый код - https://github.com/BoryaMogila/clean-code-javascript-ru

## Импорты
- Первый импорт должен быть React, если это React компонент
- Вторая секция все что касается startupjs и react библиотек
- Третья секция библиотеки из node_modules
- Четвертая секция всевозможные helpers и кастомные хуки
- Пятая секция компоненты которые импортируются через точку (к примеру './Item' или '.\./Div')
- В последнию очередь импортятся стили

## Пропсы
- children
- Все пропсы связанные со стилями (н-р: backdropStyle, Style обязательно должен быть **последним** словом)
- Далее пропсы по мере значимости
- В конце пропсы колбеки (н-р: onChange)

## Структура React компонентов
- Объявление хуков. Хуки нужно инитить сразу, т.к. во всем жизненном цикле компонента их должно быть одинаковое кол-во
- Запросы в API. Могут зависеть от state (н-р: какой-нибудь limit для query)
- useEffect\`ы - где-то по-середине
- какие-то функции хелперы - события, большие сеттеры (н-р: onChangeName). Стрелочные функции из-за hoisting использовать не стоит, всегда надо писать именованные функции: `function onChangeName () {}`.
- перед рендерингом работа со стилями, парсинг чилдренов, или формирование jsx какого-нибудь в переменные и т.д. (н-р: функция renderDropdownItem, которая возвращает сформированный jsx)

Сложную логику надо помещать либо в хелперы, либо в хуки, чтобы был виден только контекст. Например `useAdmin()` какой-нибудь или сложная агрегация впринципе не нужна в компоненте для постоянного обзора. Ты понимаешь что функция вернет сложный запрос и каким он примерно будет по названию. В идеале, код должен читаться как “на английском”.

## Работа со state
При использовании useState, жеталельно сразу задавать значение по-умолчанию, т.е. если это строка, то useState(''), если объект - {} либо null, число - 0, флаг (булево значение) -- false.
В js нет строгой типизации, поэтому когда сразу по дефолтному значению понимаешь тип переменной, то это очень облегчает жизнь, так как заранее можно предположить что эта переменная может делать. Естественно менять на какой-то другой тип в процессе нельзя (кроме редких исключений).

Если вы рендерите в цикле (через `map` или через pug'овский `each in` ) достаточно сложную верстку, то лучше сразу вынести ее в отдельный файл, как отдельный компонент.
К примеру, есть массив юзеров, их рендер подразумевает что будет использоваться [`Collapse`](https://startupjs-ui.dmapper.co/docs/components/Collapse), т.е. рендерятся юзеры с полями `avatar`, `username`, `dateReg`, а их доп. поля скрыты в `Collapse`. 
Соответственно для использования Collapse нужен какой-то state для каждого из этих элементов, в теории можно создать boolean массив и при нажатии менять значение по индексу
```javascript
const onChangeShowItem (index) {
    showItems[index] = !showItems[index]
    setShowItems([...showItems])
}
```
Однако, если Collapse работает с анимацией, либо у него есть какая-то задержка до вызова onChange, может произойти так, что при одновременном нажатии произойдет race condition, т.е. при одновременном вызове функции `onChangeShowItem`, `showItems` - будет иметь одинаковое значение. В итоге одно значение перезапишет другое.
А если каждому элементу массива, сделать отдельный компонент, в котором будет state `isOpen`, такой проблемы уже не будет, плюс так гараздо удобнее читать код и управлять подобными состояниями.

## Наименование переменных
**Boolean** с приставками - is или has (isShow, hasDefaultValue)

Все **события/колбеки/функции** - в зависимости от действия, должны начинаться на глагол
- События - с приставкой `on` (onChange, onDismiss)
- Сеттеры (функции которые что-то изменяют, но ничего не возвращают) - с приставкой `set`
- Геттеры (функции которые возвращают какое-то значение) - `get`
- Например функция которая что-то преобразует с приставкой to - toLatin(string)
- Что-то парсит - приставка parse
- и т.д.

`ref`ы - с суффиксом `Ref`, например, `inputRef`

`style` - с суффиксом `Style`, например, `containerStyle`

Какие-то другие переменные, с привязкой к сущностям, типа если width - то это width рутовый, т.е. непосредственно относящийся к компоненту текущему, если userWidth - то понятно, уже к вложенной какой-то сущности в компоненте (н-р может быть так - userAvatarSize, в компоненте есть объект/компонент юзер, в нем аватарка, в ней размер).

## Патерны
### renderItem
Допустим у компонента есть определенная логика. Самый простой пример FlatList, его чилдрены рендерятся в зависимости от расположения скролла (как в профилях instagram и еще много где - бесконечная оптимизированная лента).
Есть логика для рендеринга компонентов, но нужно как-то их кастомирировать.
Для примера юзается 2 пропса:
data - массив объектов с данными
renderItem - функция которая будет вызвана для каждого элемента массива при рендеринге

Как это пишется под капотом:
```javascript
function UserInfo ({ data, renderItem }) {
    return data.map((item, index)=> {
        if (renderItem) {
            // если есть renderItem
            // передаем ему текущий элемент массива
            return renderItem(item, index)
        } else {
            // если нет, к примеру рендерим что-то дефолтное
            return pug`
                Div(key=index)
                    Span= item.username
            `
        }
    })
}
```

Как это юзать:
```javascript
const MOCK_USERS = [
    { username: 'user1', age: 18 },
    { username: 'user1', age: 24 }
]

function Home () {
    // функция на каждой итерации принимает значения
    // и задает какой jsx нужно рендерить
    function renderItem (item, index) {
        return pug`
            Avatar
            Div(key=index)
                Span= item.username
        `
    }
    
    return pug`
        Header
        UserInfo(
            data=MOCK_USERS
            renderItem=renderItem
        )
        Footer
    `
}
```

Необязательно использовать renderItem с массивом, сама суть в том чтобы написать сложную логику и дать возможность ее кастомизировать, прокинуть дополнительно какие-нибудь пропсы.

### Root.Item
Если компонент большой, в нем много пропсов, его чилдрены разбиты на составляющие, делать кастомизацию через renderItem\`ы будет накладно.
К примеру есть компонент Modal, в нем есть Modal.Header, Modal.Actions, Modal.Content.
Банальное сравнение:

```pug
Modal(isVisible=isVisible)
    Modal.Header(title='Modal title')
    Modal.Content
        Span Modal content
    Modal.Actions
        Div(onPress=onDismiss)
            Span Cancel
        Div(onPress=onSuccess)
            Span Ok
```

renderItem:
```javascript
function renderHeader (title) {
    return pug`
        Span=title 
    `
}

function renderContent () {
    return pug`
        Span Modal content
    `
}

function renderActions () {
    return pug`
        Div(onPress=onDismiss)
            Span Cancel
        Div(onPress=onSuccess)
            Span Ok
    `
}

return pug`
    Modal(
        isVisible=isVisible
        headerTitle='Modal title'
        renderHeader=renderHeader
        renderContent=renderContent
        renderActions=renderActions
    )
`
```

9 строчек вместо 30. Если кода и так много в компоненте + еще 3 функции, они будут всегда выпадать из виду. Подход через вложенные компоненты выглядит куда более акурантым.
Так же такой подход будет более полезен если нужно применять рекурсию, например в компонентах с меню.
```pug
Menu(
    activeValue=activeValue
    onChange=v=> setActiveValue(v)
)
    Menu.Item(value='home')
        Span Home
    Menu.Item(value='about')
        Span About
    Menu.Item(value='contacts')
        Span Contacts
```
[Наглядный пример](https://reactnative.dev/docs/picker.html)

Menu.Item - подразумевает обертку для нажатия, в чилдренах которой может содержаться все что угодно.
И при любом нажатии вызывается рутовый onChange в который прилетит значение нажатого чилдрена. Под капотом компонент поймет какой Item активен и что с ним нужно делать.
